<!DOCTYPE html>
<html>
<head>
    <title>psi-feature-burnup</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0rc1/lib/analytics/analytics-all.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/async/1.22/async.min.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                // utility methods

// returns the release name if the app is on a page scoped to a release.
function getReleaseTimeBox(app) {
    var timeboxScope = app.getContext().getTimeboxScope();
    var tbName = null;
    if(timeboxScope) {
        var record = timeboxScope.getRecord();
        tbName = record.get('Name');
    } else {
        tbName = "";
    }
    return tbName;
}

// generic function to perform a web services query
function wsapiQuery( config , callback ) {

    Ext.create('Rally.data.WsapiDataStore', {
        autoLoad : true,
        limit : "Infinity",
        model : config.model,
        fetch : config.fetch,
        filters : config.filters,
        listeners : {
            scope : this,
            load : function(store, data) {
                callback(null,data);
            }
        }
    });
}

function snapshotQuery( config ,callback) {

    var storeConfig = {
        find    : config.find,
        fetch   : config.fetch,
        hydrate : config.hydrate,
        autoLoad : true,
        pageSize : 10000,
        limit    : 'Infinity',

        listeners : {
            scope : this,
            load  : function(store,snapshots,success) {
                console.log("snapshots:",snapshots.length);
                callback(null,snapshots);
            }
        }
    };
    var snapshotStore = Ext.create('Rally.data.lookback.SnapshotStore', storeConfig);

}

function pointsUnitType(type) {
        return type=="Points";
}

//
// Default settings for the Rally App (in utilities, because these keys are also used in createSeries Array)
//
function getDefaultSettings() {
    return {
        releases                : "",
        epicIds                 : "",
        ignoreZeroValues        : true,

        StoryPoints             : true,
        StoryPointsProjection   : true,
        AcceptedStoryPoints     : true,
        AcceptedPointsProjection: true,

        DefectPoints            : true,
        AccDefectPoints         : true,

        P0StoryPoints           : true,
        P0AccStoryPoints        : true,
        P0StoryPointsProjection : true,
        P0AccStoryPointsProjection: true
    };
}

function createSeriesArray() {
    return [
        { name : "StoryPoints" ,             description : "Total Points",          field : "LeafStoryPlanEstimateTotal", display : "line", f : "sum", color : "DarkGray" },
        { name : "StoryPointsProjection",    description : "Scope Projection",  projectOn : "Total Points", color : "LightGray" },
        { name : "AcceptedStoryPoints",      description : "Accepted Points",       field : "AcceptedLeafStoryPlanEstimateTotal", display : "line", f : "sum", color : "Green" },
        { name : "AcceptedPointsProjection", description : "Accepted Projection", projectOn : "Accepted Points",        color : "LightGray" },

        { name : "DefectPoints" ,           description : "Defect Points",       field : "PlanEstimate",
            filterField: "c_Type", filterValues: ['DEFECT'], display : "line", f : "filteredSum", color: "Orange" },
        { name : "AccDefectPoints" ,        description : "Accepted Defect Points",       field : "c_AcceptedPlanEstimate",
            filterField: "c_Type", filterValues: ['DEFECT'], display : "line", f : "filteredSum", color: "Blue" },

        { name : "P0StoryPoints" ,           description : "P0 Points",       field : "LeafStoryPlanEstimateTotal",
            filterField: "c_Priority", filterValues: ['P0'], display : "line", f : "filteredSum", color: "Black" },
        { name : "P0AccStoryPoints" ,           description : "P0 Accepted Points",       field : "AcceptedLeafStoryPlanEstimateTotal",
            filterField: "c_Priority", filterValues: ['P0'], display : "line", f : "filteredSum", color: "DarkRed" },
        { name : "P0StoryPointsProjection",    description : "P0 Scope Projection",  projectOn : "P0 Points",
            filterField: "c_Priority", filterValues: ['P0'], display : "line", f : "filteredSum", color: "LightGray" },

        { name : "P0AccPointsProjection", description : "P0 Accepted P0 Projection", projectOn : "P0 Accepted Points",
            filterField: "c_Priority", filterValues: ['P0'], display : "line", f : "filteredSum", color: "LightGray" }
    ];
}

function createColorsArray( series ) {

    var colors = [];

    _.each( series, function(s,i) {
        if (i>0) {
            var as = _.find( app.series, function(a) {
                return a.description === s.name;
            });
            if (!_.isUndefined(as)) {
                colors.push(as.color);
            } else {
                colors.push("LightGray");
            }

        }
    });

    return colors;

}


function trimHighChartsConfig(hc) {

    // trim future values
    var today = new Date();
    _.each(hc, function(series,i) {
        // for non-projection values dont chart after today
        if (series.name.indexOf("Projection")===-1 && series.name.indexOf("label") ===-1 ) {
            _.each( series.data, function( point , x ){
                if ( Date.parse(hc[0].data[x]) > today )
                    series.data[x] = null;
            });
        }
        // for projection null values before today.
        if (series.name.indexOf("Projection")!==-1) {
//            console.log("projection series",series);
            _.each( series.data, function( point , x ){
                if ( Date.parse(hc[0].data[x]) < today ) {
                    series.data[x] = null;

                }
            });
//                series.color = "#C8C8C8";
            series.dashStyle = 'dash';
        }

    });

    return hc;
}

                var app = null;

Ext.define('CustomApp', {
    scopeType: 'release',
    extend: 'Rally.app.App',
    componentCls: 'app',
    itemId: 'burnupApp',

    items: [
        {
            xtype: 'panel',
            itemId: 'topPanel',
            layout: { type: 'hbox', align: 'left' },

            items: [{
                xtype: 'rallyreleasecombobox',
                fieldLabel: 'Release:',
                labelAlign: 'right',
                margin: 8,
                width: 300,
                itemId: 'releaseCombo',
                listeners: {
                    ready: function () {
                        var app = this.up('#burnupApp');

                        app.setSelectedRelease(this);  // This is scoped to the the combobox object
                    },
                    select: function () {
                        var app = this.up('#burnupApp');

                        app.setSelectedRelease(this);  // This is scoped to the the combobox object
                    }
                }
            }, {
                xtype: 'rallybutton',
                itemId: 'selectBurnupLinesButton',
                labelAlign: 'right',
                margin: 8,
                text: "Burnup Display",
                menu: [
                    {
                        xtype: 'menucheckitem',
                        itemId: 'showP0s',
                        text: 'P0 Burnup Lines',
                        checked: false,
                        handler: function(checkbox, showLabels) {
                        	app.createAndShowBurnupChart();
                        }
                    }, {
                        xtype: 'menucheckitem',
                        itemId: 'showDefects',
                        text: 'Defect Burnup Lines',
                        checked: false,
                        handler: function(checkbox, showLabels) {
                        	app.createAndShowBurnupChart();
                        }
                    }, {
                        xtype: 'menucheckitem',
                        itemId: 'showProjections',
                        text: 'Completion Projection Lines',
                        checked: false,
                        handler: function(checkbox, showLabels) {
                        	app.createAndShowBurnupChart();
                        }
                    }, { xtype: 'menuseparator' }, {
                        xtype: 'menucheckitem',
                        itemId: 'milestoneLabels',
                        text: 'Milestone Labels',
                        checked: true,
                        handler: function(checkbox) {
                            var showLabels	= checkbox.checked;

                            app.removePlotLines('milestone');
                            app.addPlotLines('milestone', showLabels);
                        }
                    }, {
                        xtype: 'menucheckitem',
                        itemId: 'iterationLabels',
                        text: 'Iteration Labels',
                        checked: true,
                        handler: function(checkbox) {
                            app.removePlotLines('iterationStart');
                            app.addPlotLines('iterationStart');
                        }
                    }, {
                        xtype: 'menucheckitem',
                        itemId: 'iterationLines',
                        text: 'Iteration Lines',
                        checked: true,
                        handler: function(checkbox) {
                            app.removePlotLines('iterationStart');
                            app.removePlotLines('iterationEnd');

                            app.addPlotLines('iterationStart');
                            app.addPlotLines('iterationEnd');
                        }
                    }, { xtype: 'menuseparator' }, {
                        xtype: 'menucheckitem',
                        itemId: 'iterationOverlap',
                        text: 'Overlaping Iteration Dates',
                        checked: true,
                        handler: function(checkbox) {
                            app.removePlotLines('iterationEnd');
                            app.addPlotLines('iterationEnd');
                        }
                    }, { xtype: 'menuseparator' }, {
                        xtype: 'menucheckitem',
                        itemId: 'showVelocityTables',
                        text: 'Velocity Tables',
                        checked: true,
                        handler: function(checkbox) {
                            var panel = app.down('#velocityTablePanel');

                            if (checkbox.checked) {
                                panel.show();
                            } else {
                                panel.hide();
                            }
                        }
                    }]
            }, {
                xtype: 'rallybutton',
                itemId: 'selectFeatureButton',
                labelAlign: 'right',
                margin: 8,
                text: "Burnup Components",
                listeners: {
                    menuhide: function(button, event, eOpts) {
                        app.displayFeatureSelection();
                    },
                    click: function(button, event, eOpts) {

                    	if (!app.featureRecords) {
                            var release = app.releases && app.releases[0];
                            var relName = release && release.get('Name');

                            button.menu.setLoading(true);

                            app.featureToNameMap = {};

                            var config = {
                                model  : app.featureType,
                                fetch  : ['Name', 'FormattedID',
                                          'LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal'],
                                filters: [{
                                    property: 'Release.Name',
                                    operator: '=',
                                    value: relName
                                }]
                            };
                            app.wsapiQuery(config, function(err, featureRecords) {
                                // Sort by effort remaining to complete
                                featureRecords = _.sortBy(featureRecords, function(rec) {
                                        var tot		= rec.get('LeafStoryPlanEstimateTotal');
                                        var done	= rec.get('AcceptedLeafStoryPlanEstimateTotal');
                                        var rem		= tot - done;

                                        return -rem;
                                });

                                _(featureRecords).forEach(function(featureRecord) {
                                    var name 		= featureRecord.get('Name');
                                    var id	 		= featureRecord.get('FormattedID');
                                    var totalPoints = featureRecord.get('LeafStoryPlanEstimateTotal');
                                    var donePoints	= featureRecord.get('AcceptedLeafStoryPlanEstimateTotal');
                                    var remPoints	= totalPoints - donePoints;

                                    app.featureToNameMap[id] = name;

                                    button.menu.add({ text: '<b>' + id + '</b>: ' + name +
                               			' <span style="font-size:9px">(' +
                                    	remPoints + ': ' + donePoints + '/' + totalPoints + ')</span>',
                                    	xtype: 'menucheckitem', value: id, checked: true,
                                    	handler:  function(checkbox) {
                                            if (checkbox.checked) {
                                                app.setCheckbox('selectNone', false);
                                            } else {
                                                app.setCheckbox('selectAll', false);
                                            }
                                        }
                                	});
                                });

                                app.featureRecords = featureRecords;
                                button.menu.setLoading(false);
                            });
                    	}
                    }

                },

                menu: [
                       {
                           xtype: 'menucheckitem',
                           text: 'Select All',
                           itemId: 'selectAll',
                           checked: true,
                           handler: function(checkbox) {
                                var checked	= checkbox.checked;

                                if (checked) {
                                    app.setAllInSelectMenu(true);
                                }
                           }
                       }, {
                           xtype: 'menucheckitem',
                           text: 'Select None',
                           itemId: 'selectNone',
                           handler: function(checkbox) {
                                var checked	= checkbox.checked;

                                if (checked) {
                                    app.setAllInSelectMenu(false);
                                }
                           }
                       }, { xtype: 'menuseparator' }, {
                           xtype: 'menucheckitem',
                           text: 'Include Defects',
                           itemId: 'includeDefects',
                           handler: function(checkbox) {
                                var checked	= checkbox.checked;

                                if (checked) {
                                    app.setCheckbox('selectNone', false);
                                } else {
                                    app.setCheckbox('selectAll', false);
                                }
                           },
                           checked: true
                       }, { xtype: 'menuseparator' }
                ]
            }
           ]

        }, {
            xtype: 'panel',
            layout: 'fit',
            items: [
                {
                    xtype: 'panel',
                    itemId: 'chartPanel',
                    layout: 'fit',
                    minHeight: 500,
                    minWidth: 100
                }
            ]
        }, {
            xtype: 'panel',
            itemId: 'velocityTablePanel',
            bufferedRenderer: true,
            layout: { type: 'hbox', align: 'left' }
        }
    ],

    //
    // Once the user has changed the selection of burnup features and defects, display that
    //
    displayFeatureSelection: function() {
        var button				= app.down('#selectFeatureButton');
        var menuItems			= button.menu.items.items;
        var selectedFeatures	= [];
        var ignoredFeatures		= [];

        _(menuItems).forEach(function(menuItem) {
            if (menuItem.value && menuItem.checked) {
                selectedFeatures.push(menuItem.value);

            } else if (menuItem.value && !menuItem.checked) {
                ignoredFeatures.push(menuItem.value);
            }
        });

        app.selectedFeatures = selectedFeatures;
        app.ignoredFeatures	 = ignoredFeatures;

        app.createAndShowBurnupChart();
    },

    //
    // Feature selection is the widget that selects particular features to display in the burndown.
    // If it is null, then that means display all features in the release, which is the default display.
    //
    resetFeatureSelection: function () {
        this.selectedFeatures = null;
        this.ignoredFeatures = null;

        this.featureRecords = null;
    },

    allFeaturesSelected: function() {
        var button		= app.down('#selectFeatureButton');
    	var menu		= button.menu;
        var allSelected = true;

    	_(menu.items.items).forEach(function(menuItem) {
            if (menuItem.value && menuItem.checked === false) {
                allSelected = false;
            }
    	});

        return allSelected;
    },

    //
    // Check all the boxes in the feature select menu
    //
    setAllInSelectMenu: function(selectValue) {
        var button	= app.down('#selectFeatureButton');
    	var menu	= button.menu;

        // console.log(menu);

    	_(menu.items.items).forEach(function(menuItem) {
            var text = menuItem.text;

           //  console.log(text, menuItem);

            if (menuItem.xtype == 'menuseparator') {
                // Probably the separator

            } else if (text == 'Select None') {
                if (selectValue) {
                    menuItem.setChecked(false);
                }
            } else {
                menuItem.setChecked(selectValue);
            }
    	});
    },

    getCheckboxValue: function(checkBoxId) {
        var checkbox = this.down('#' + checkBoxId);

        // console.log(checkBoxId, checkbox);

        return checkbox.checked;
    },

    setCheckbox: function(checkBoxId, value) {
        var checkbox = this.down('#' + checkBoxId);

        checkbox.setChecked(value);
    },

    milestoneLabels: function() { return this.getCheckboxValue('milestoneLabels'); },
    iterationLabels: function() { return this.getCheckboxValue('iterationLabels'); },
    showP0s:		 function() { return this.getCheckboxValue('showP0s'); },
    showDefects:	 function() { return this.getCheckboxValue('showDefects'); },
    showProjections: function() { return this.getCheckboxValue('showProjections'); },
    onlyP0s:		 function() { return false; }, // Used to be a checkbox, but now since we have the P0 lines as well, no longer needed

    includeDefects:  function() { return this.getCheckboxValue('includeDefects'); }, // Don't include defects if we are  listing features

    // Called when the release combo box is ready or selected.  This triggers the building of the chart.
    setSelectedRelease: function(releaseCombo) {
        var releaseName = releaseCombo.getRecord().data.Name;
        this.defaultRelease = releaseName;

        this.resetFeatureSelection();

        this.resetData();
        this.createChart();
    },

	getTestPicker: function() {
		Ext.Loader.setConfig({ enabled: true });
		Ext.Loader.setPath('Ext.ux', '/ux');
		var store = Ext.create('Ext.data.Store', {
				fields: ['id', 'type'],
				data:
				[
					{id: '1', type: 'option one'},
					{id: '2', type: 'option two'},
					{id: '3', type: 'option three'},
					{id: '4', type: 'option four'},
					{id: '5', type: 'option five'},
					{id: '6', type: 'option six'},
					{id: '7', type: 'option seven'}
				]
			});

		return {
			xtype: 'rallymultiobjectpicker',
			fieldLabel: 'Include In Burnup:',
			labelAlign: 'right',
			rowSelectable: true,
			margin: 8,
			listCfg:  {selModel: {mode: 'SIMPLE'}, displayField: "type", pageSize: 0, autoScroll: true, cls: 'rui-multi-object-list'},
            store: store,
            /*
			storeConfig: {
				context: this._getScopeLimitedContext(),
				sorters: [{ // does not seem to work...
						property: 'ReleaseDate',
						direction: 'ASC'
					}],
				listeners: {
					load: setCheckboxesFromPrefs,
					scope: this
				}
			},
            */
			listeners: {
//				added:				function(picker) { this.releasePicker = picker; },
//				selectionchange:	recordSelectionAsReleaseFilters,
//				blur:				setCardboardFiltersFromPrefs,

				scope:				this
			}
//			modelType: 'release',
//			renderTo: Ext.getBody().dom
		};
	},

    launch: function() {
		this.velocityCalc = new VelocityCalculator(this);

        /*
        var picker = this.getTestPicker();
        var panel	= this.down('#topPanel');

        panel.add(picker);
        */
    }, // No launch function currently needed: createChart is triggered when a release is ready or selected

    // switch to app configuration from ui selection
    config: {
        defaultSettings : getDefaultSettings()
    },

    getSettingsFields: function() {

        var checkValues = _.map(createSeriesArray(),function(s) {
            return { name : s.name, xtype : 'rallycheckboxfield', label : s.description};
        });

        var values = [
            {
                name: 'releases',
                xtype: 'rallytextfield',
                label : "Release names to be included (comma seperated)"
            }, {
                name: 'epicIds',
                xtype: 'rallytextfield',
                label : "(Optional) List of Parent PortfolioItem (Epics) ids to filter Features by"
            }, {
                name: 'featureIds',
                xtype: 'rallytextfield',
                label : "(Optional) List of PortfolioItem ids to exclusively show"
            }, {
                name: 'ignoreZeroValues',
                xtype: 'rallycheckboxfield',
                label: 'For projection ignore zero values'
            }
        ];

        _.each(values,function(value){
            value.labelWidth = 250;
            value.labelAlign = 'left';
        });

        return values.concat(checkValues);
    },

    //
    // Check if the end data of a group if iterations overlaps the end date
    //
    iterationsDontOverlap: function(iterations) {
        var overlap	= true;
        var iter1 	= iterations[0];

        if (iter1 && iterations.length > 1) {
            var i;
            var iter1Name = iter1.get('Name');
            var iter2 = null;

            for (i = 1; i < iterations.length; i++) {
                var curName = iterations[i].get('Name');

                if (curName != iter1Name) {
                    iter2 = iterations[i];
                    break;
                }
            }

            if (iter1 && iter2) {
                var iter1End	= Ext.Date.format(iter1.get('EndDate'), 'Y-M-d');
                var iter2Start	= Ext.Date.format(iter2.get('StartDate'), 'Y-M-d');

                overlap = iter1End < iter2Start;
            }
        }

        return overlap;
    },

    createChart: function() {
        if (!app) {
            app = this;
        }
        app.setLoading(true);

        app.series           = createSeriesArray();
        app.configReleases   = app.getSetting("releases") || app.defaultRelease;
        app.ignoreZeroValues = app.getSetting("ignoreZeroValues");
        app.epicIds          = app.getSetting("epicIds");
//        app.featureIds       = app.getSetting("featureIds");

        if (app.configReleases === "") {
            this.resetChart("Please Configure this app by selecting Edit App Settings from Configure (gear) Menu");
            return;
        }

        // get the project id.
        this.project = this.getContext().getProject().ObjectID;

        // get the release (if on a page scoped to the release)
        var tbName = getReleaseTimeBox(this);
        // release selected page will over-ride app config
        app.configReleases = tbName !== "" ? tbName : app.configReleases;

        var configs = [];

        // query for estimate values, releases and iterations.
        configs.push({ model : "Release",
                       fetch : ['Name', 'ObjectID', 'Project', 'ReleaseStartDate', 'ReleaseDate' ],
                       filters: [app.createReleaseFilter(app.configReleases)]
        });
        configs.push({ model : "TypeDefinition",
                       fetch : true,
                       filters : [ { property:"Ordinal", operator:"=", value:0} ]
        });
        configs.push({ model : "Milestone",
                       fetch : ['Name', 'TargetDate', 'DisplayColor'],
                       filters : [
                                Ext.create('Rally.data.QueryFilter', { property:'Projects', operator: 'contains', value:'project/' + this.project }).or(
                                Ext.create('Rally.data.QueryFilter', { property:'TargetProject', operator: '=', value: null })).and(
                                Ext.create('Rally.data.QueryFilter', { property:'TargetDate', operator: '!=', value: null }))
                       ],
                       sorters: [{
                           property: 'TargetDate',
                           direction: 'ASC'
                       }]
        });

        // get the preliminary estimate type values, and the releases.
        async.map( configs, app.wsapiQuery, function(err,results) {

            app.releases    = results[0];
            app.featureType = results[1][0].get("TypePath");
            app.milestones  = results[2];

            if (app.releases.length === 0) {
                app.resetChart("No Releases found with this name: " + app.configReleases);

                return;
            }

            configs = [
                {
                    model  : "Iteration",
                    fetch  : ['Name', 'ObjectID', 'Project', 'StartDate', 'EndDate'],
                    filters: app.createIterationFilter(app.releases), // XXX app.Releases is an array!
                    sorters: [{
                       property: 'StartDate',
                       direction: 'ASC'
                    }]
                }
            ];

            // get the iterations
            async.map( configs, app.wsapiQuery, function(err,results) {
                var iterations = results[0];

                if (!app.iterations && app.iterationsDontOverlap(iterations)) {
                    app.setCheckbox('iterationOverlap', false);
                }
                app.iterations = iterations;

                var includeDefects = app.includeDefects();

                if ((includeDefects && app.defectSnapshots) || (!includeDefects && app.featureSnapshots)) {
                    app.createAndShowBurnupChart();

                } else {
                    app.queryFeatureSnapshots();

                    /* If we are not going to limit to particular ids, then this query is not necessary:
                     * we can just query for all PI's associated with a release
                    if (app.epicIds && app.epicIds.split(",")[0] !== "")
                        app.queryEpicFeatures();
                    else
                        app.queryFeatures();
                     */
                }

            });
        });
    },

    // remove leading and trailing spaces
    trimString : function (str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },

    // creates a filter to return all releases with a specified set of names
    createReleaseFilter : function(releaseNames) {

        var filter = null;

        _.each( releaseNames.split(","), function( releaseName, i ) {
            if (releaseName !== "") {
                var f = Ext.create('Rally.data.wsapi.Filter', {
                        property : 'Name', operator : '=', value : app.trimString(releaseName) }
                );
                filter = (i===0) ? f : filter.or(f);
            }
        });

        console.log("Release Filter:",filter.toString());
        return filter;

    },

    // Given several releases, find the earliest starting date and latest ending date of all of them
    // Then create a filter that matches any iterations whose end date is >= the earliest release starting date
    // and <= the latest release ending date
    createIterationFilter : function(releases) {

        var extent = app.getReleaseExtent(releases);

        var filter = Ext.create('Rally.data.wsapi.Filter', {
            property : 'EndDate', operator: ">=", value: extent.isoStart
        });

        filter = filter.and( Ext.create('Rally.data.wsapi.Filter', {
                property : 'EndDate', operator: "<=", value: extent.isoEnd
            })
        );

        return filter;
    },

    // Given several releases, find the earliest starting date and latest ending date of all of them
    getReleaseExtent : function( releases ) {

        var start = _.min(_.pluck(releases,function(r) { return r.get("ReleaseStartDate");}));
        var end   = _.max(_.pluck(releases,function(r) { return r.get("ReleaseDate");}));
        var isoStart  = Rally.util.DateTime.toIsoString(start, false);
        var isoEnd    = Rally.util.DateTime.toIsoString(end, false);

        return { start : start, end : end, isoStart : isoStart, isoEnd : isoEnd };

    },

    // generic function to perform a web services query
    wsapiQuery : function( config , callback ) {

        Ext.create('Rally.data.WsapiDataStore', {
            autoLoad : true,
            limit : "Infinity",
            model : config.model,
            fetch : config.fetch,
            filters : config.filters,
            listeners : {
                scope : this,
                load : function(store, data) {
                    callback(null,data);
                }
            },
            sorters: config.sorters
        });

    },

    resetData: function() {
        delete this.defectSnapshots;
        delete this.featureSnapshots;
    },

    resetChart: function(mesg) {
        app.setLoading(false);

        var chart = app.down("#chart1");
        if (chart !== null) {
            chart.removeAll();
        }


        if (mesg) {
            Rally.ui.notify.Notifier.show({message: mesg, color: 'red'});
        } else {
            Rally.ui.notify.Notifier.hide();
        }
    },

    // No longer used
    executeFeatureQuery: function(filter) {
        return Ext.create('Rally.data.WsapiDataStore', {
            autoLoad: true,
            model : app.featureType,
            limit : 'Infinity',
            fetch: ['ObjectID', 'FormattedID'],
            filters: [filter],
            listeners: {
                load: function(store, features) {
                    console.log("Loaded:"+features.length," Features.");

                    app.features = features;

                    if (app.features.length === 0) {
                        app.resetChart('No features found for this release');

                    } else {
                        app.queryFeatureSnapshots();
                    }
                }
            }
        });
    },

    // No longer used
    queryEpicFeatures : function() {
        var filter = null;
        var epicIds = app.epicIds.split(",");

        if (epicIds.length === 0) {
            app.resetChart("No epic id's specified");

            return;
        }

        _.each(epicIds, function( epicId, i) {
            var f = Ext.create('Rally.data.QueryFilter', {
                property: 'Parent.FormattedID',
                operator: '=',
                value: epicId
            });
            filter = i === 0 ? f : filter.or(f);
        });

        app.executeFeatureQuery(filter);
    },

    // No longer used
    queryFeatures : function() {
        var filter = null;
        var releaseNames = _.uniq(_.map(app.releases,function(r){ return r.get("Name");}));

        console.log("releaseNames", releaseNames);

        _.each( releaseNames , function( release, i ) {
            var f = Ext.create('Rally.data.QueryFilter', {
                property: 'Release.Name',
                operator: '=',
                value: release
            });
            filter = i === 0 ? f : filter.or(f);
        });

        app.executeFeatureQuery(filter);
    },

    //
    // User can choose to limit the feature ids
    // from which the burnup is created
    //
    getSpecificFeatureIds: function() {
        var features = !app.allFeaturesSelected() && app.selectedFeatures;

//        features = ['F1020'];

        return features;
    },

    getSnapshotFilters: function(type) {
        // var ids = _.pluck(app.features, function(feature) { return feature.get("ObjectID");} );
        // var pes = _.pluck(app.features, function(feature) { return feature.get("PreliminaryEstimate");} );
        // console.log("ids",ids,pes);

        var extent = app.getReleaseExtent(app.releases);
        var relIDs = _.map(app.releases, function (release) { return release.data.ObjectID; });
        var filters;

        if (type === 'defect') {
            filters = {
                '_TypeHierarchy': { "$in" : ["Defect"] },
                'Release':		  { "$in" : relIDs },
                'PlanEstimate':   { "$gt" : 0 },
                '_ValidTo':		  { "$gte" : extent.isoStart }
            };

        } else {
            filters = {
                    '_TypeHierarchy': { "$in" : [app.featureType] },
                    'Release': 		  { "$in" : relIDs },
                    '_ValidTo':	      { "$gte" : extent.isoStart }
                };


            // If the feature has chosen to view certain featureIDs, find those; otherwise get all associated with the
            // matching release Ids
            var featureIds = this.getSpecificFeatureIds();

            if (featureIds) {
                filters.FormattedID = { "$in" : featureIds };
            } else {
                filters.Release     = { "$in" : relIDs };
            }

            if (app.onlyP0s()) {
                filters.c_Priority = { "$in": ['P0']};
            }
        }

        return filters;
    },

    queryFeatureSnapshots : function () {
        var defectStoreFilters  = this.getSnapshotFilters('defect');

        var defectStoreConfig = {
            find: defectStoreFilters,
            autoLoad : true,
            pageSize: 1000,
            limit: 'Infinity',
            fetch: ['PlanEstimate', 'ScheduleState'],
            hydrate: ['ScheduleState'],
            listeners: {
                load: function(store, snapshots, success) {
                    if (snapshots) {
                        console.log("Loaded:"+snapshots.length," Defects snapshots", success);
                    }

                    if (success === false) {
                        Rally.ui.notify.Notifier.show({message: "Failed to load defect data"});
                    }
                    app.gotSnapshotData('defects', snapshots);
                }
            }
        };

        var featureStoreFilters = this.getSnapshotFilters('feature');
        var featureStoreConfig = {
            find : featureStoreFilters,
            autoLoad : true,
            pageSize:1000,
            limit: 'Infinity',
//            fetch: ['_UnformattedID','ObjectID','_TypeHierarchy','PreliminaryEstimate', 'LeafStoryCount','LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal','AcceptedLeafStoryCount','PercentDoneByStoryCount','RefinedEstimate']
//            fetch: ['LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal']
            fetch: ['LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal', 'c_Priority', 'FormattedID'],
            hydrate: ['c_Priority']
        };

//        console.log('releases', _.map(app.releases, function (release) { return release.data.ObjectID; }));

        featureStoreConfig.listeners = {
            scope : this,
            load: function(store, snapshots, success) {
                console.log("Loaded:"+snapshots.length," Feature Snapshots.", success);

                if (success === false) {
                    Rally.ui.notify.Notifier.show({message: "Failed to load user story data"});
                }
                app.gotSnapshotData('features', snapshots);
            }
        };

        if (!this.featureSnapshots) {
            console.log("Querying for feature snapshots", featureStoreConfig.find);
            Ext.create('Rally.data.lookback.SnapshotStore', featureStoreConfig);
        }
        if (this.includeDefects()) {
            console.log("Querying for defects snapshots", defectStoreConfig.find);
            Ext.create('Rally.data.lookback.SnapshotStore', defectStoreConfig);
        }
    },

    //
    // Make defectsSnapshots look like feature Snapshots by populating "Total" fields
    // that our found in feature level portfolio items
    //
    normalizeDefectSnapshotData: function(defectSnapshots) {

        app.defectTotalPoints = 0;
        app.defectAcceptedPoints = 0;

        _(defectSnapshots).forEach(function(defect) {
            var planEstimate = defect.data.PlanEstimate;

            defect.data.LeafStoryPlanEstimateTotal = planEstimate;

            defect.data.c_Priority = 'P0'; // Defects all considered P0
            defect.data.c_Type = 'DEFECT'; // Identify as a defect

            app.defectTotalPoints += planEstimate;
            if (defect.data.ScheduleState === 'Accepted') {
                app.defectAcceptedPoints += planEstimate;
            }

            defect.data.AcceptedLeafStoryPlanEstimateTotal =
                defect.data.ScheduleState === 'Accepted' ? defect.data.PlanEstimate : 0;

            defect.data.c_AcceptedPlanEstimate =
                defect.data.ScheduleState === 'Accepted' ? defect.data.PlanEstimate : 0;
        });

        return defectSnapshots;
    },

    gotSnapshotData: function(type, snapshots) {
        if (type == 'defects') {
            app.defectSnapshots = app.normalizeDefectSnapshotData(snapshots);

        } else if (type == 'features') {
            app.featureSnapshots = snapshots;
        }

        // Make sure we have all the data needed before drawing the graph
        if ((!app.includeDefects() || app.defectSnapshots) && app.featureSnapshots) {
            app.createAndShowBurnupChart();
        }
    },

    getFilterIdMap: function() {
        var featureIds = this.getSpecificFeatureIds();
        var map		   = null;

        if (featureIds) {
            map = {};

            _(featureIds).forEach(function(fid) {
                map[fid] = 1;
            });
        }

        return map;
    },

    //
    // Filter snapShot data based on filterMap
    //
    // Any defects should be passed through-- those are filtered elsewhere.
    //
    filterSnapShotFeatureData: function (snapShotData) {
        var filterMap		= this.getFilterIdMap();
        var filteredData	= [];

        if (filterMap === null) {
            filteredData = snapShotData;

        } else {
            _(snapShotData).forEach(function(snapShot) {
                // If no FormattedID, then its a defect, and those if those are filtered earlier
            	// so just pass them through.
            	//
            	// If a formated ID, only let them through if they are listed in the filter map
            	//
                if (!snapShot.FormattedID || filterMap[snapShot.FormattedID]) {
                    filteredData.push(snapShot);
                }
            });
        }

        return filteredData;
    },

    createAndShowBurnupChart : function () {
//        console.log('createChart', app, app.featureSnapshots, app.defectSnapshots);
        var snapshots    = this.includeDefects() && app.defectSnapshots ?
                            app.featureSnapshots.concat(app.defectSnapshots) : app.featureSnapshots;
        var lumenize     = window.parent.Rally.data.lookback.Lumenize;
        var snapShotData = this.filterSnapShotFeatureData(_.map(snapshots,function(d){return d.data;}));
        var extent       = app.getReleaseExtent(app.releases);

        // can be used to 'knockout' holidays
        var holidays = [
            //{year: 2014, month: 1, day: 1}  // Made up holiday to test knockout
        ];

        var myCalc = Ext.create("MyBurnCalculator", {
            series : app.series,
            ignoreZeroValues : app.ignoreZeroValues,
            peRecords : app.peRecords
        });

        // calculator config
        var config = {
            deriveFieldsOnInput: myCalc.getDerivedFieldsOnInput(),
            metrics: myCalc.getMetrics(),
            summaryMetricsConfig: [],
            deriveFieldsAfterSummary: myCalc.getDerivedFieldsAfterSummary(),
            granularity: lumenize.Time.DAY,
            tz: 'America/Chicago',
            holidays: holidays,
            workDays: 'Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday'
        };
        // release start and end dates
        var startOnISOString = new lumenize.Time(extent.start).getISOStringInTZ(config.tz);
        var upToDateISOString = new lumenize.Time(extent.end).getISOStringInTZ(config.tz);
        // create the calculator and add snapshots to it.
        calculator = new lumenize.TimeSeriesCalculator(config);
        calculator.addSnapshots(snapShotData, startOnISOString, upToDateISOString);

        // create a high charts series config object, used to get the hc series data
        var hcConfig = [{ name : "label" }];
        _.each( app.series, function(s) {
            if (app.getSetting(s.name) === true) {
                var desc = s.description;

                if (desc.match('P0') && !app.showP0s()) {
                    // skip
                } else if (desc.match('Defect') && !app.showDefects()) {
                    // skip

                } else if (desc.match('Projection') && !app.showProjections()) {
                    // skip
                } else {
                    hcConfig.push({
                       name : s.description, type : s.display
                    });
                }
            }
        });
        var seriesData = calculator.getResults().seriesData;
        var hc = lumenize.arrayOfMaps_To_HighChartsSeries(seriesData, hcConfig);

        this.showChart( trimHighChartsConfig(hc) );

        this.velocityCalc.addGrids(seriesData, app.milestones, app.iterations);
    },

    getChartXAxis: function() {
        var chart = app.down("highchart").chart;
        var xAxisArray = chart.xAxis;

        return xAxisArray[0];
    },

    removePlotLines: function(labelHead) {
        var xAxis		= this.getChartXAxis();
        var plotLines	= xAxis.plotLinesAndBands;
        var ids			= [];
            _(plotLines).forEach(function(plotLine) {
                if (plotLine && plotLine.id.match(labelHead + '-')) {
                    ids.push(plotLine.id);
                }
            });

        _(ids).forEach(function(id) {
            xAxis.removePlotLine(id);
        });
    },

    addPlotLines: function(plotLineType) {
        var showLabelTitles = plotLineType === 'milestone' ?
        					this.getCheckboxValue('milestoneLabels') :
        				    this.getCheckboxValue('iterationLabels') && plotLineType == 'iterationStart';
        var xAxis			= this.getChartXAxis();
        var plotLines = plotLineType === 'milestone' ?
        				this.getMilestonePlotLineConfigs(app.seriesDates, showLabelTitles) :
        				this.getIterationPlotLineConfigs(app.seriesDates, showLabelTitles, plotLineType);

        if (!plotLineType.match('iteration') || app.getCheckboxValue('iterationLines')) {
            _(plotLines).forEach(function(plotLine) {
                xAxis.addPlotLine(plotLine);
            });
        }
    },

    //
    // Return an array of plotlines.
    //
    //   seriesDates: An array of all the dates that will be displayed in the graph
    //   recordArray: An array of the record type we want to create plot lines for (release, iteration or milestone)
    //     dateField: The name of the field that accesses the "date" field for records in recordArray
    // plotLineStyle: Style of the plot line to be passed to highcharts.  Also contains several special fields that we interpret here
    //
    //                 showLabel: Label the plotline as the name of the record it represents (e.g. Milestone Name)
    //              plotLineType: 'milestone' and 'iterationStart' have special labels
    //							  'iterationEnd' has no labels
    //                     color: Enter an explit color, otherwise it will try to lookup the DisplayColor of the object (works for Milestones),
    //                            else it will default to grey
    //
    // showLabel notes:
    //
    // We want to display milestone plotLines similar to how they are displayed in the "Portfolio -> Timeline" page in Rally.
    // Those are just a dotted line with diamond at the top colored to match the color of the milestone.
    //
    // We could not find a way to display a diamond, but the character "8" in the Rally font is a downward pointing triangle/arrow
    // which is pretty close.  So we will display that in the color of the milestone.
    //
    getPlotLineConfigs: function(seriesDates, recordArray, dateField, plotLineStyle) {
        var plotLineLevels	= 3;  // How many levels to display plotline labels (to avoid rendering collisions)
        var plotLineHeight	= 0;
        var plotLineType	= plotLineStyle.plotLineType || 'unknown';

        var plotLineConfigs = _.map(recordArray, function(record){
            var date = new Date(Date.parse(record.raw[dateField]));
                if (plotLineType == 'iterationEnd' && !app.getCheckboxValue('iterationOverlap')) {
					// For some groups interations start and end on the same day, but not all.
                    // So unfortunately this fix to avoid "double" iteration lines is not enough.

                    date.setDate(date.getDate() + 1);
                }
            var dateStr = date.toISOString().split("T")[0];

            var color = plotLineStyle.color || record.get("DisplayColor") || "grey";
            var labelHTML = '<span style="font-family:Rally;color:' + color + '">8</span>'; // 8 is a downward pointing triangle in the Rally font
            var labelTitle = record.get("Name");

            // We will show the plot line of the end date one day after the start

            var plotLineConfig = {
                dashStyle: "Dot",
                color: color,
                width: 1,
                value: _.indexOf(seriesDates, dateStr)
            };

            if (plotLineType == 'milestone') {
                var text = labelHTML;
                var yLabelOffset = -1;

                if (plotLineStyle.showLabelTitles) {

                    yLabelOffset = 15 * plotLineHeight;
//                        text += '<br><span>\u00A0\u00A0\u00A0</span>';  Does not work with IE

                    text += labelTitle; // + '(' + yLabelOffset + ')';
                }

                plotLineConfig.label = {
                    text: text,
                    rotation: 0,
                    verticalAlign: 'top',
                    x: -6,
                    y: yLabelOffset,
                    textAlign: 'left',
                    useHTML: true
                };

                plotLineHeight = plotLineHeight == plotLineLevels-1 ? 0 : plotLineHeight + 1;

            } else if (plotLineType == 'iterationStart' && plotLineStyle.showLabelTitles) {
                plotLineConfig.label = {
                    text: labelTitle,
                    rotation: 270,
                    y: -5,
                    x: 10,
                    verticalAlign: 'bottom'
                };
            }

            if (plotLineType) {
                var name       = record.get("Name");
                var plotLineId = plotLineType + '-' + name;

                plotLineConfig.id = plotLineId;

                plotLineConfig.events = {
                    click: function () {
                        var axis        = this.axis;

                        axis.removePlotLine(plotLineId);
                    }/*,

                    mouseover: function () {
                        var axis        = this.axis;
                        var newPlotLine	= _.clone(plotLineConfig);
                        var oldLabel	= _.clone(this.label);
                        var labelRE		= new RegExp(labelText);

                        if (this.label.text.match(labelRE)) {
                            newPlotLine.label.text = labelHTML;

                        } else {
                            newPlotLine.label.text = labelHTML + labelText;
                        }

                        axis.removePlotLine(plotLineId);
                        axis.addPlotLine(newPlotLine);
                    },
                    mouseout: function () {
                    }*/
                };
            }

            _.each(plotLineStyle, function(value, key) {
                plotLineConfig[key] = value;
            }, this);


            return plotLineConfig;
        });
        return plotLineConfigs;
    },

    getMilestonePlotLineConfigs: function(seriesDates, showLabelTitles) {
        var plotLineStyle	= { dashStyle: 'dash', width: 2, showLabel: true, showLabelTitles: showLabelTitles, plotLineType: 'milestone'};

        return this.getPlotLineConfigs(seriesDates, this.milestones, 'TargetDate', plotLineStyle);
    },

    getIterationPlotLineConfigs: function(seriesDates, showLabelTitles, type) {
        var plotLineType	= type == 'iterationStart' ? 'iterationStart'	: 'iterationEnd';
        var dateField		= type == 'iterationStart' ? 'StartDate'		: 'EndDate';
        var start = new Date( Date.parse(seriesDates[0]));
        var end   = new Date( Date.parse(seriesDates[seriesDates.length-1]));

        var iterations = _.filter(this.iterations,function(i) { return i.get("EndDate") >= start && i.get("EndDate") <= end;});
            iterations = _.uniq(iterations ,function(i) { return i.get("Name");});

        var plotLineStyle	= { dashStyle: 'dot', color: 'grey', showLabelTitles: showLabelTitles, plotLineType:  plotLineType};

		return this.getPlotLineConfigs(seriesDates, iterations, dateField, plotLineStyle);
    },

    //
    // Given an array of all the dates plotted in the graph, return an array of plot lines.
    //
    // Plot lines are vertical lines that appear in the graph.  There are three types:
    //
    // * Iteration Plot lines: end dates of iterations
    // * Release Plot lines: stat and end dates of iteration
    // * Milestone Plot lines: target dates of milestones
    //
    // Iteration and Release plot lines are just a dotted grey lines.
    //
    // Milestone plot lines are thicker and colored to match the milestone, which a indicator at the top and
    // the name of the milestone displayed.
    //
    // Milestone plot lines can be temporarily removed from the graph by clicking on them.
    //
    getAllPlotLineConfigs: function(seriesDates) {
        var itLines		 = app.getCheckboxValue('iterationLines');
        var itPlotLines  = itLines ? this.getIterationPlotLineConfigs(seriesDates, this.iterationLabels(), 'iterationStart') : [];
        var itEPlotLines = itLines ? this.getIterationPlotLineConfigs(seriesDates, false, 'iterationEnd') : [];
        var rePlotLines  = this.getPlotLineConfigs(seriesDates, this.selectedReleases, 'ReleaseDate', { dashStyle: 'dot', color: 'grey'} );
        var miPlotLines  = this.getMilestonePlotLineConfigs(seriesDates, this.milestoneLabels());

        return itPlotLines.concat(itEPlotLines).concat(rePlotLines).concat(miPlotLines);
    },

    getChartTitle: function() {
        var title = '';

        var fids	= app.getSpecificFeatureIds();
        if (fids && fids.length === 0) {
          	if (this.includeDefects()) {
                title = 'Only showing Defects';
          	} else {
                title = 'No features or defects selected';
          	}

        } else if (fids) {
            var ignored = app.ignoredFeatures || [];

            if (fids.length <= ignored.length) {
                if (fids.length == 1) {
                    title = "Limited to feature " + fids[0] + ': ' + this.featureToNameMap[fids[0]];

                } else {
                    title = "Limited to features: " + fids.join(', ');
                }

              	if (this.includeDefects()) {
                    title += ' and Defects';
              	}
            } else {
                if (ignored.length == 1) {
                    title = "Excluding feature " + ignored[0] + ': ' + this.featureToNameMap[ignored[0]];
                } else {
                    title = "Excluding features: " + ignored.join(', ');
                }

              	if (!this.includeDefects()) {
                    title += ' and Defects';
              	}
            }

        } else {
          	if (!this.includeDefects()) {
                title += 'Not showing Defects';
          	}
        }

        // Because if we have no title, the spacing changes
        if (title === '') { title = ' '; }

        return title;
    },

    showChart : function(series) {
        app.resetChart();
        app.seriesDates = series[0].data;

        // create plotlines
        var plotlines = this.getAllPlotLineConfigs(app.seriesDates);

        // set the tick interval
        var tickInterval = series[1].data.length <= (7*20) ? 7 : (series[1].data.length / 20);
        var title	= this.getChartTitle();
        var extChart = Ext.create('Rally.ui.chart.Chart', {
            columnWidth : 1,
            itemId : "chart1",
            chartData: {
                categories : series[0].data,
                series : series.slice(1, series.length)
            },

            chartColors : createColorsArray(series),

            chartConfig : {
                chart: { },
                title: {
                    text: title,
                    x: -20 //center
                },
                plotOptions: {
                    series: {
                        marker: {
                            radius: 2
                        }
                    }
                },
                xAxis: {
                    plotLines : plotlines,
                    //tickInterval : 7,
                    tickInterval : tickInterval,
                    type: 'datetime',
                    labels: {
                        formatter: function() {
                            return Highcharts.dateFormat('%b %d', Date.parse(this.value));
                        }
                    }
                },
                yAxis: {
                    title: {
                        text : 'Points/Count'
                    },
                    plotLines: [{
                        value: 0,
                        width: 1,
                        color: '#808080'
                    }]
                },
                tooltip: {
                },
                legend: { align: 'center', verticalAlign: 'bottom' },
                renderTo: Ext.getBody()
            }
        });
//        var size = extChart.getSize();

        var panel = app.down('#chartPanel');
        panel.add(extChart);

        app.clearLoadingBug();
    },

    //
    // Even though we don't seem to set it explicitly, the chart is left with
    // the loading mask on.  This hack turns it off in FireFox and Explorer.
    //
    clearLoadingBug: function() {
//      chart = this.down("#chart1");
        var p = Ext.get(this.id);
        var elems = p.query("div.x-mask").concat(p.query("div.x-mask-msg"));

        _.each(elems, function(e) {
            if (typeof e.remove === 'function') {
                e.remove();

            } else if (typeof e.removeNode === 'function') {
                while (e.firstChild) {
                    e.removeChild(e.firstChild);
                }
                e.removeNode();
            }
        });
    }

});

                Ext.define("MyBurnCalculator", function() {

    var self;

    return {

        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",

        config : {
            series : [],
            ignoreZeroValues : true,
            peRecords : []

        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            return this;
        },

        pointsOffset: [],
        countOffset: [],
        data: [],
        indexOffset: [],

        getMetrics: function () {

            // get the set of non-projection metrics
            var nonProjectionMetrics = _.filter(self.series,function(s) {
               return s.name.indexOf("Projection")==-1;
            });

            var metrics = _.map( nonProjectionMetrics, function(m) {
                var row = {
                    field : m.field,
                    as : m.description,
                    display : m.display,
                    f : m.f
                };
                if (m.filterField) {
                    row.filterField = m.filterField;
                    row.filterValues = m.filterValues;
                }

                return row;
            });

            return metrics;
        },

        getDerivedFieldsOnInput : function () {
            // XS 1, S 3, M 5, L 8, XL 13
            return [
                {
                    as: 'CalcPreliminaryEstimate',
                    f:  function(row) {
                        var r = _.find(self.peRecords, function(rec) { return rec.get("ObjectID") == row.PreliminaryEstimate; });
                        var v = r !== undefined ? r.get("Value") : 0;
                        return v;
                    }
                },
                {
                    as: 'Completed',
                    f:  function(row) {
                    return row.PercentDoneByStoryCount == 1 ? 1 : 0;
                    }
                }
            ];
        },

        getMidPointIndex : function(dateSeries) {

            var today = new Date();

            var tdi = _.findIndex(dateSeries,function(d) {
                return ( today.setHours(0,0,0,0) === new Date(Date.parse(d)).setHours(0,0,0,0));
            });

            return tdi !== -1 ? Math.round(tdi/2) : -1;

        },

        calcProjectionPoint : function(seriesName,projectOn,row, index, summaryMetrics, seriesData, projectFrom) {

            var that = this;

            // for first point we save the data set on which we are going to do the linear projection on
            // we also optionally filter out values.
            if (index === 0) {
                datesData = _.pluck(seriesData,"label");
                var mid = self.getMidPointIndex(datesData);
                var today = new Date();
                var li = datesData.length-1;

                // that.data[seriesName] = _.pluck(seriesData,seriesName);
                that.data[seriesName] = _.pluck(seriesData,projectOn);
                // if (seriesName==="Story Points") console.log(that.data[seriesName].length);
                // filter to just values before today
                that.data[seriesName] = _.filter(
                    that.data[seriesName], function(d,i) {
                        if (!_.isUndefined(projectFrom) && projectFrom==="mid") {
                            return (i < mid);
                        } else {
                            return new Date(Date.parse(datesData[i])) < today;
                        }
                    }
                );
                // if (seriesName==="Story Points") console.log(that.data[seriesName].length);
                // optionally remove zero values
                var dx = that.data[seriesName].length;
                if (self.ignoreZeroValues===true) {
                    that.data[seriesName] = _.filter(
                        that.data[seriesName], function(d,i) {
                            return d !== 0;
                        }
                    );
                }
                // if (seriesName==="Story Points") console.log(that.data[seriesName].length);
                // if we do remove values from the data set then we need to save an offset
                // so we are calculating the projection on the revised length
                var dy = that.data[seriesName].length;
                that.indexOffset[seriesName] = dx - dy;

                // calculate an offset between the projected value and the actual accepted values.
                var lastAccepted = that.data[seriesName][that.data[seriesName].length-1];
                var lastProjected = linearProject( that.data[seriesName], that.data[seriesName].length-1);
                // if (seriesName==="Story Points")
                //     console.log("la",lastAccepted,"lp",lastProjected);
                that.pointsOffset[seriesName] = lastAccepted-lastProjected;
            }
            index = index - that.indexOffset[seriesName];
            var y = linearProject( that.data[seriesName], index) + that.pointsOffset[seriesName];
            return Math.round(y * 100) / 100;
        },

        getDerivedFieldsAfterSummary : function () {

            // get the set of projection metrics
            var projectionMetrics = _.filter(self.series,function(s) {
                return s.name.indexOf("Projection")!==-1;
            });

            var metrics = _.map( projectionMetrics, function(m) {
                return {
                    as : m.description,
                    projectOn : m.projectOn,
                    projectFrom : m.projectFrom,
                    name : m.name,
                    f : function(row,index,summaryMetrics,seriesData) {
                        var p = self.calcProjectionPoint(this.name,this.projectOn,row,index,summaryMetrics,seriesData,this.projectFrom);
                        return p;
                    }
                };

            });

            return metrics;

        },

        defined : function(v) {
            return (!_.isUndefined(v) && !_.isNull(v));
        }
    };

});

                function LineFitter()
{
    this.count = 0;
    this.sumX = 0;
    this.sumX2 = 0;
    this.sumXY = 0;
    this.sumY = 0;
}

LineFitter.prototype = {
    'add': function(x, y)
    {
        this.count++;
        this.sumX += x;
        this.sumX2 += x*x;
        this.sumXY += x*y;
        this.sumY += y;
    },
    'project': function(x)
    {
        var det = this.count * this.sumX2 - this.sumX * this.sumX;
        var offset = (this.sumX2 * this.sumY - this.sumX * this.sumXY) / det;
        var scale = (this.count * this.sumXY - this.sumX * this.sumY) / det;
        return offset + x * scale;
    }
};

function linearProject(data, x)
{
    var fitter = new LineFitter();
    for (var i = 0; i < data.length; i++)
    {
        fitter.add(i, data[i]);
    }
    return fitter.project(x);
}

function projectToZero( data, x) {

    var start = x;

    while ( linearProject(data,start) > 0)
        start = start + 1;

    return start;

}
                Ext.define("VelocityCalculator", {
    app: null,
    gridPanelId: '#velocityTablePanel',

    storeFields: ['startName', 'endName', 'days', 'acceptVelocity', 'acceptDelta', 'scopeVelocity', 'scopeDelta',
                    'acceptPoints', 'accPointsPerMo',
        	         'segmentVelPerMo', 'segmentVel'],

    constructor: function(theApp) {
        this.app = theApp;

        return this;
    },

    today: function() {
        return Ext.Date.format(new Date(), 'Y-m-d');
    },

    resetPanel: function() {
        var panel  = this.app.down(this.gridPanelId);

        if (panel !== null) {
            panel.removeAll();
        }
    },

    addGridsToPanel: function (grids) {
        var panel = this.app.down(this.gridPanelId);

        _.each(grids, function(newGrid) {
            panel.add(newGrid);
        });
        panel.update();
    },

    addGrids: function(seriesData, milestones, iterations) {
        this.resetPanel();

        this.createDateCollection(seriesData);

        this.addGridsToPanel([
        		 this.getOverallVelocityGrid(seriesData),
        		 this.getIterationVelocityGrid(seriesData, iterations),
        		 this.getMilestoneVelocityGrid(seriesData, milestones)
        ]);
    },

    calcDoneDate: function(totalPoints, acceptedPoints, avgMoVelocity) {
        var avgDayVelocity	= avgMoVelocity.match(/^\d+(\.\d+)?$/) ? Math.round(avgMoVelocity/30) : '';
        var daysToFinish	= avgDayVelocity ? Math.round((totalPoints - acceptedPoints)/avgDayVelocity) : '';
        var doneDate		= daysToFinish === '' ? 'n/a' : Ext.Date.format(Ext.Date.add(new Date(), Ext.Date.DAY, daysToFinish), 'Y-m-d');

        return doneDate;
    },

    calcPct: function(num, total) {
        var pct	= total ? Math.round(num/total*100) : '-';

        return pct;
    },

    addPctToNum: function(num, total) {
        var pct	= this.calcPct(num, total);

        return num + ' (' + pct + '%)';
    },

    getOverallStats: function(seriesData, P0) {
        var entryCount 		= seriesData.length - 1;
        var firstEntry		= seriesData[0];
        var lastEntry		= seriesData[entryCount];
        var startDate		= firstEntry.label;
        var endDate			= lastEntry.label;
        var today			= this.today();
        var compDate		= today < endDate ? today : endDate;

        var acceptField		= P0 === true ? 'P0 Accepted Points' : 'Accepted Points';
        var storyField		= P0 === true ? 'P0 Points' : 'Total Points';

        var startAccPoints	= Math.round(firstEntry[acceptField]);
        var acceptedPoints	= Math.round(lastEntry[acceptField]);
        var curAccPoints	= acceptedPoints - startAccPoints;
        var totalPoints		= Math.round(lastEntry[storyField]);
        var remainingPoints	= totalPoints - acceptedPoints;
        var totalDays	  	= this.subtractDates(endDate, startDate);
        var daysPast	  	= this.subtractDates(compDate, startDate);
        var monthsPast	    = daysPast / 30;
        var daysPct			= totalDays ? Math.round(daysPast/totalDays*100) + '%' : '-';
        var avgMoVelocity	= monthsPast ? Math.round(curAccPoints/monthsPast).toString() : '-';
 //       var avgDayVelocity	= daysPast ? Math.round(curAccPoints/daysPast) : '0';
//        var daysToFinish	= avgDayVelocity ? Math.round((totalPoints - acceptedPoints)/avgDayVelocity) : '';
        var doneDate		= this.calcDoneDate(totalPoints, acceptedPoints, avgMoVelocity);

        return {
            avgMoVelocity:	avgMoVelocity,
            totalPoints:	totalPoints,
            acceptedPoints:	acceptedPoints,
            remainingPoints:this.addPctToNum(remainingPoints, totalPoints),
            daysPct:		daysPct,
            doneDate:		doneDate
        };
    },

    getOverallVelocityGrid: function(seriesData) {
        var totalStats		= this.getOverallStats(seriesData, false);
        var p0Stats			= this.getOverallStats(seriesData, true);

		var getEditorFunc = function(record) {
			var edit		= record && record.get('edit');
			var formType	= 'Ext.form.field.Number';
			var formConfig	= null;

			return edit === true ? Ext.create('Ext.grid.CellEditor', { field: Ext.create(formType, formConfig)}) : null;
		};

        var stats			= [
                 { stat: 'Avg. Velocity / Month',  value: totalStats.avgMoVelocity,  P0Value: p0Stats.avgMoVelocity, edit: true },
                 { stat: 'Total Points',           value: totalStats.totalPoints,    P0Value: p0Stats.totalPoints, edit: true },
                 { stat: 'Accepted Points',        value: totalStats.acceptedPoints, P0Value: p0Stats.acceptedPoints },
                 { stat: 'Remaining Points',       value: totalStats.remainingPoints,P0Value: p0Stats.remainingPoints },
                 { stat: '% Time Used',            value: totalStats.daysPct,		 P0Value: p0Stats.daysPct },
                 { stat: 'Completion Estimate',    value: totalStats.doneDate,		 P0Value: p0Stats.doneDate }
           ];
        var store	= Ext.create('Ext.data.Store', {
            	storeId: 'overallVelocityStore',
            	fields: ['stat', 'value', 'P0Value', 'edit'],
                data: { 'items': stats },
                proxy: { type: 'memory', reader: { type: 'json', root: 'items' } }
            });

        var that = this;
        var newGrid = Ext.create('Ext.grid.Panel', {
//            minHeight: 200,
            bufferedRenderer: true,
            title: 'Overall Stats',
            itemId: 'velocityStatsGrid',
            store: store,
            columns: [
                      { text: 'Statistic',  dataIndex: 'stat', flex: 200, align: 'right' },
                      { text: 'All',		dataIndex: 'value', getEditor: getEditorFunc},
                      { text: 'P0 Only',    dataIndex: 'P0Value', getEditor: getEditorFunc}
            ],
			plugins: [{
				ptype: 'cellediting',
				clicksToEdit: 1,
                listeners: {
                    edit: function(editor, e) {
                        console.log('we were edited', e);

                        if (e.value != e.originalValue) {
                            var grid	= e.grid;
                            var field	= e.field;
                            var models	= grid.getStore().getRange();

                            var velocity	= models[0].get(field).toString();
                            var totPoints	= models[1].get(field).toString();
                            var accPoints	= models[2].get(field).toString();
                            var remPoints	= this.addPctToNum(totPoints-accPoints, totPoints);

                            console.log('calc', totPoints, accPoints, velocity);

                            var doneDate = that.calcDoneDate(totPoints, accPoints, velocity);

                            models[5].set(field, doneDate); // Set new done date

                            models[3].set(field, remPoints); // Set new points remaining
                        }
                    },
            		scope: this
                }
			}],
            width: 400,
            renderTo: Ext.getBody()
        });

        return newGrid;
    },

    //
    // Create a collection of dates from seriesData so that we can lookup
    // points by dates;
    //
    createDateCollection: function(seriesData) {
        var dateCollection = {};
            _.each( seriesData, function(pointData) {
                var date		= pointData.label;

                dateCollection[date] = pointData;
            });

        return this.dateCollection = dateCollection;
    },

    todayPointData: function() {
        var today = this.today();

        return this.dateCollection[today];
    },

    addVelocitySegmentEntry: function(items, name, nextName, date, nextDate) {
        var pointData	  = date && this.dateCollection[date];
        var nextPointData = nextDate && this.dateCollection[nextDate];

        if (this.dateIsFuture(date)) {
        	// Skip stuff that has not yet happened

        } else if (pointData && nextPointData) {
            	if (nextDate > this.today()) { // Truncate to today, if the segment ends after the current date
                    var todayPointData = this.todayPointData();

                    if (todayPointData) {
                        nextPointData = this.todayPointData();
                        nextDate	  = this.today();
                	}
            	}
            var acceptedDiff  = nextPointData['Accepted Points'] - pointData['Accepted Points'];
            var scopeDiff	  = nextPointData['Total Points'] - pointData['Total Points'];
            var days	  	  = this.subtractDates(nextDate, date);
            var months		  = days / 30;

            if (!_.isNaN(acceptedDiff)) {
                items.push({
                    startName:		name,
                    endName:		nextName + ' (' + days + ' days)',
                    days:			days,
                    segmentVel:		Math.round(acceptedDiff - scopeDiff),
                    segmentVelPerMo:months ? Math.round((acceptedDiff - scopeDiff)/months * 100) / 100 : '-',

                    acceptPoints:   Math.round(acceptedDiff),
                    accPointsPerMo: months ? Math.round((acceptedDiff)/months * 100) / 100 : '-',

                    acceptDelta:    this.velocityStr(acceptedDiff, months),
                    scopeDelta:     this.velocityStr(scopeDiff, months),
                    effectiveVel:   this.velocityStr(acceptedDiff - scopeDiff, months)
                });
            }
        }
    },

    getIterationItems: function(iterations, seriesData) {
        var items			= [];
        var that			= this;
        var today			= this.today();

        var uniqIterations = _.sortBy(_.uniq(_.map(iterations, function(i){ return i.raw;}), 'Name'), 'StartDate');

        _.each( uniqIterations, function(iteration) {
            var date	  = iteration.StartDate.replace(/T.*/, '');
            var nextDate  = iteration.EndDate.replace(/T.*/, '');
            var name	  = iteration.Name;
            var nextName  = name;

            that.addVelocitySegmentEntry(items, name, nextName, date, nextDate);
        });
        return items;
    },

    getIterationVelocityGrid: function(seriesData, iterations) {
        var items	= this.getIterationItems(iterations, seriesData);
        var store	= Ext.create('Ext.data.Store', {
            	storeId: 'iterationVelocityStore',
            	fields: this.storeFields,
                data: { 'items': items },
                proxy: { type: 'memory', reader: { type: 'json', root: 'items' } }
            });

        var newGrid = Ext.create('Ext.grid.Panel', {
            title: 'Iteration Velocities',
            itemId: 'iterationVelocitiesGrid',
            store: store,
            columns: [
                      { text: 'Iteration',       dataIndex: 'endName', flex: 300, align: 'right', hidden: false },
                      { text: 'Accepted Points',     dataIndex: 'acceptPoints', hidden: false},
                      { text: 'Acc / Month', dataIndex: 'accPointsPerMo', hidden: false },
                      { text: 'Effective Velocity', dataIndex: 'segmentVel', hidden: true },
                      { text: 'Scope Change',        dataIndex: 'scopeDelta', hidden: true }
            ],
            width: 400,
            renderTo: Ext.getBody()
        });

        return newGrid;
    },

    getMilestoneVelocityGrid: function(seriesData, milestones) {
        this.milestones = milestones;

        var items	= this.getMilestoneItems(seriesData);
        var store	= Ext.create('Ext.data.Store', {
            	storeId: 'milestoneVelocityStore',
            	fields: this.storeFields,
                data: { 'items': items },
                proxy: { type: 'memory', reader: { type: 'json', root: 'items' } }
            });

        var newGrid = Ext.create('Ext.grid.Panel', {
            title: 'Milestone Segment Velocities',
            itemId: 'milestoneVelocitiesGrid',
            store: store,
            columns: [
                      { text: 'Segment Start',   dataIndex: 'startName', flex: 200, hidden: true  },
                      { text: 'Segment End',       dataIndex: 'endName', flex: 200, align: 'right' },
                      { text: 'Segment Velocity', dataIndex: 'segmentVel' },
                      { text: 'SV / Month', dataIndex: 'segmentVelPerMo' },
                      { text: 'Accepted Points',     dataIndex: 'acceptDelta', hidden: true},
                      { text: 'Scope Change',        dataIndex: 'scopeDelta', hidden: true }
            ],
            width: 400,
            renderTo: Ext.getBody()
        });

        return newGrid;
    },

    //
    // Initialize the milestoneDates collection, used to calculate segment velocities
    // With the start end end date of the release
    //
    initializeMilestoneSegments:  function (seriesData) {
        var start		   = seriesData[0];
        var startDate	   = start.label;

        var end			   = seriesData[seriesData.length-1];
        var endDate		   = end.label;

        var milestoneDates = {};

    	milestoneDates[startDate] = {
                pointData: start,
                milestoneList:[{ Name: 'Start of Release' }]
    		};

    	milestoneDates[endDate] = {
                pointData: end,
                milestoneList:[{ Name: 'End of Release' }]
    		};
        milestoneDates[startDate].pointData.nextDate = endDate;

    	return milestoneDates;
    },

    // Populate milestoneSegments:
    //   keys are the dates of the milestones
    //   values are: the data that exists on the graph at that date (filled in later) and an array of Milestones for that date
    //
    populateMilestoneSegmentDates: function(seriesData) {
        var milestoneDates	= this.initializeMilestoneSegments(seriesData);
        var relStartDate 	= seriesData[0].label; // Date of the end of the release
        var end				= seriesData[seriesData.length-1];
        var relEndDate 		= end.label; // Date of the end of the release
        var today		   = Ext.Date.format(new Date(), 'Y-m-d');

        var that = this;
        var lastDate		= relStartDate; // Date of the last segment end as we step through them
        _.every( this.milestones.reverse(), function(milestone) {
            var data = milestone.raw;
            var date = data.TargetDate.replace(/T.*/, '');

            if (date > today) {
                data.Name = 'Today - ' + today;
            }

            if (date > relStartDate && date < relEndDate) {
                var dateInfo = milestoneDates[date];
                    if (!dateInfo) { dateInfo = milestoneDates[date] = { pointData: {}, milestoneList:[] }; }

                dateInfo.milestoneList.push(data);

                if (lastDate) {
                    milestoneDates[lastDate].pointData.nextDate = date;
                }
                lastDate = date;
            }

           	return !that.dateIsFuture(date); // Quit once we get past the current date
        });

        return milestoneDates;
    },

    getMilestoneItems: function(seriesData) {
        var items	 	= [];
        var that		= this;

        var milestoneDates = this.populateMilestoneSegmentDates(seriesData);

        //
        // Step through the chart series data, and fill in the pointDate information into milestoneDates
        //
        _.each( seriesData, function(pointData) {
            var date		= pointData.label;
            var dateEntry	= milestoneDates[date];

            if (dateEntry) {
            	dateEntry.pointData = _.extend(dateEntry.pointData, pointData);
            }

        });

        //
        // Step through milestoneDates, and create a velocity entry each segment between
        // the Start of the release, each milestone and the end of the release or current date
        //
        _.each( milestoneDates, function(data, date) {
            var pointData = data.pointData;
            var nextDate  = pointData.nextDate;

            if (that.dateIsFuture(date)) {
            	// Skip stuff that has not yet happened

            } else if (nextDate) {
                var nextName	  = milestoneDates[nextDate].milestoneList[0].Name;

                _.each( data.milestoneList, function(milestone) {
                    var name = milestone.Name;

                    that.addVelocitySegmentEntry(items, name, nextName, date, nextDate);
                });
            }
        });
        return items;
    },

    dateIsFuture: function(dateStr) {
        var date	= Ext.Date.parse(dateStr, 'Y-m-d');
        var today	= new Date();

        return date > today;
    },

    velocityStr: function(pointDelta, months) {
        var velocity	  = Math.round(pointDelta / months * 100) / 100 ;

        return pointDelta  + ' (' + velocity + '/mo)';
    },

    subtractDates: function(d1, d2) {
        var date1 = new Date(d1);
        var date2 = new Date(d2);
        var diff  = date1.getTime() - date2.getTime();

        return diff / (24*60*60*1000);
    }
});


            Rally.launchApp('CustomApp', {
                name:"psi-feature-burnup",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
/* check combo */
.x-combo-checker {
  background-position: 50% -2px;
  margin-left: 1px;
  background-color: transparent;
  background-image: url("https://rally1.rallydev.com/apps/2.0rc1/lib/ext/4.1.1a/resources/themes/images/default/grid/unchecked.gif");
  background-position: -1px -1px;
  background-repeat: no-repeat;
  height: 14px;
  width: 14px;
  display: inline-block;
}
.x-boundlist-selected .x-combo-checker {
  background-image: url("https://rally1.rallydev.com/apps/2.0rc1/lib/ext/4.1.1a/resources/themes/images/default/grid/checked.gif");
}

    </style>
</head>
<body>
</body>
</html>
